#!/usr/bin/env python3

# TODO:
# * Error handling
# * Log all commands into workspace
# * De-couple WorkSpace from GitRepos
# * Write unit tests
# * Handle corrupt dependencies.json
# * Handle exceptional conditions
# * Use a real logger
# * Handle partial sha1s correctly

 
import argparse
from workspace import WorkSpace, GitRepo
import logging
import os
import sys
from collections import OrderedDict

logging.basicConfig(level = logging.INFO)
log = logging.getLogger('wit')


def main() -> None:
    # Parse arguments. Create sub-commands for each of the modes of operation
    parser = argparse.ArgumentParser()
    parser.add_argument('-v', '--verbose', action='store_true')
    parser.add_argument('-d', '--debug', action='store_true')
    parser.add_argument('--repomap', default=None)
    subparsers = parser.add_subparsers(dest='command', help='sub-command help')

    init_parser = subparsers.add_parser('init', help='create workspace')
    init_parser.add_argument('-a', '--add', metavar='repo', help='add an initial repo')
    init_parser.add_argument('workspace_name')

    add_parser = subparsers.add_parser('add', help='add repo to workspace')
    add_parser.add_argument('repo_name')

    subparsers.add_parser('status', help='show status of workspace')
    subparsers.add_parser('update', help='update git repos')

    args = parser.parse_args()

    if args.verbose:
        log.setLevel(logging.WARNING)
        
    elif args.debug:
        log.setLevel(logging.DEBUG)

    else:
        log.setLevel(logging.INFO)

    ws = WorkSpace(args.repomap)
    # FIXME: This big switch statement... no good.
    if args.command == 'init':
        create(ws, args)

    else:
        # These commands assume the workspace already exists. Error out if the
        # workspace cannot be found.
        try:
            ws.find()
            
        except FileNotFoundError as e:
            log.error("Unable to find workspace root [{}]. Cannot continue.".format(e))
            sys.exit(1)
            
        if args.command == 'add':
            add(ws, args)

        elif args.command == 'status':
            status(ws, args)

        elif args.command == 'update':
            update(ws, args)


def create(ws, args):
    log.info("Creating workspace [{}]".format(args.workspace_name))

    ws.create(args.workspace_name)
    if args.add is not None:
        source, revision = split_repo_rev(args.add)
        ws.add_repo(source=source, revision=revision)


def add(ws, args):
    log.info("Adding repo to workspace")
    source, revision = split_repo_rev(args.repo_name)
    ws.add_repo(source=source, revision=revision)


def status(ws, args):
    log.info("Checking workspace status")
    if not ws.lock:
        log.info("{} is empty. Have you run `wit update`?".format(ws.LOCK))
        return

    clean = []
    dirty = OrderedDict()
    for reponame in ws.lock:
        # FIXME: cheating by diving into the object.
        manifest_commit = ws.lock[reponame]['commit']
        repo = GitRepo.create(ws.lock[reponame]['source'], dest=ws.path)
        latest_commit = repo.get_latest_commit()

        new_commits = manifest_commit != latest_commit

        if new_commits or not repo.clean():
            status = []
            if new_commits:
                status.append("new commits")
            if repo.modified():
                status.append("modified content")
            if repo.untracked():
                status.append("untracked content")
            dirty[reponame] = status
        else:
            clean.append(reponame)

    print("Clean repos:")
    for repo in clean:
        print("    {}".format(repo))
    print("Dirty repos:")
    for repo, content in dirty.items():
        msg = ", ".join(content)
        print("    {} ({})".format(repo, msg))


def update(ws, args):
    log.info("Updating workspace")
    ws.update()


def split_repo_rev(repo_string):
    # FIXME: This is ugly. Split on '::' into a path and revision, but
    # there may not be a revision. So add an additional array
    source, rev = (repo_string.split("::") + [None])[:2]
    return source, rev


if __name__ == '__main__':
    main()
